---
title: 频繁createBitmap导致的OOM问题记录
date: 2018.05.16 17:55:11
tags: Android
toc: true
---

最近在做一个相机有关的应用，相机输出的一般来说都是需要旋转才能变为我们看来正向的图像的，这是因为相机传感器的坐标体系和屏幕不一致造成的，具体的不展开说了。但是图像输出导致的一系列问题值得记录一番。

首先是图像预览输出很慢很卡，这时候就要注意一下，`ImageReader`的输出格式不要使用`ImageFormat.JPEG`，可以使用`ImageFormat.YUV_420_888`，我猜测原因是`JPEG`格式输出的话，相机还得为我们做一次转码，在低性能手机上很容易导致卡顿，如果改了格式还卡的话，考虑一下降低图像输出的分辨率吧。至于`YUV`转`Bitmap`的话，可以网上找找`C`的库，性能比直接输出`JPEG`转`Bitmap`更高。

接下来就是图像的方向和屏幕不一致了，网上搜索旋转`Bitmap`，基本上都是说使用
>Bitmap.createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter)

来创建一个新的`Bitmap`，然后将原`Bitmap`释放掉，这时候坑就来了，在平时这样使用是没事的，但是在相机预览输出的时候就有问题了，因为相机预览输出速度很快，这种情况下`Bitmap`是来不及释放掉的，会慢慢的内存泄漏，直到最后出现内存溢出。而且`Bitmap`的创建时非常消耗内存的，这样频繁创建`Bitmap`，内存的消耗是飞速的，这时候我们可以选用另外一种方式，网上很少有人提到的方法来旋转`Bitmap`，这个方法就是使用`Canvas`。

我们知道，`Canvas`创建的时候可以传入`Bitmap`，这时候`Canvas`上的所有绘制都会直接绘制在`Bitmap`上，而且`Canvas`也有`drawBitmap`方法，可以用其他`Bitmap`做画笔，更关键的是，`drawBitmap`的重载方法里有一个是可以传入`Matrix`的，这时候解决方法就出来了，我们可以创建一个全局复用的`Bitmap`，注意大小使用旋转后的大小，然后使用它来创建`Canvas`，之后所有`bitmap`旋转都不用再生成新的`bitmap`，只要使用`canvas.drawBitmap`在全局`Bitmap`上画就行。不过事情还没完。

通过`Bitmap`创建的`Canvas`的画布大小就是`Bitmap`的大小，我们旋转`bitmap`的时候要注意，`Matrix`旋转时画笔`Bitmap`的位置是会发生变化的，最后画出来能输出到`Bitmap`上的可能只有小部分，甚至完全没有画在`Bitmap`上。这时候我们就需要在`Matrix`里面添加位移操作，来保持画笔输出位置和画布一致了，具体的位移距离就得自己算了，因为线代我已经忘干净了，所以我的做法是，拿两张纸，自己旋转完看位置......

到此，相机图像输出导致的所有问题都解决了，写出来就这么几步，但是摸索的时候也卡了我老半天，因为网上没有搜到相关的问题记录，所以记录下来以免忘记。

**——在`YUV`转`Bitmap`可以使用`libyuv`库，同时旋转操作也可以通过该库完成，如果可以，最好不要使用Java做旋转**